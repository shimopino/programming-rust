/**
 * use宣言で、標準ライブラリのトレイト FromStr をスコープに取り込む
 * トレイトは型が実装できるメソッドの集合
 * 型 u64 は FromStr を実装しており、u64::from_str メソッドを使って
 * 文字列を解析してその型の値に変換しようとする
 *
 * env は実行環境の情報を取得するための有用な関数や型が定義されている
 * 例えば args 関数で、コマンドライン引数を取得することができる
 */
use std::env;
use std::str::FromStr;

// main関数は返り値を持たないので、返り値の型を指定する必要がない
fn main() {
    // 動的な配列を定義する
    // この後で u64 型を push 指定するため、型推論によって片づけされる
    let mut numbers = Vec::new();

    // args関数は、必要に応じて引数を1つずつ作成し、引数がなくなったらそれを教えてくれる
    // イテレータを生成する関数である
    // このイテレータは最初の値としてプログラムの名前を生成するので最初はスキップする
    for arg in env::args().skip(1) {
        // from_strはResult型を返す
        // もしも結果が Err(e) の場合は expect のメッセージを出力して実行を中断する
        numbers.push(u64::from_str(&arg).expect("error parsing argument"));
    }

    if numbers.len() == 0 {
        // 標準エラー出力にメッセージを書き出している
        eprintln!("Usage: gcd NUMBER");
        std::process::exit(1);
    }

    // ベクタのサイズは任意なのでとても大きくなる可能性があるため、
    //  それぞれの値の生存期間を明確にして、不要になったメモリが即座に解放されることを保証することで
    //  プログラマがメモリを制御できるようにする
    //
    //  ベクタの要素を処理するには、ベクタの所有権自体は numbers に残しておき、
    //  ループではその要素を借りているだけだと示すために、&演算子で要素への参照を
    //  借用している
    //
    //  *mの「*」は参照解決するための演算子であり、参照先の値を返す
    //  そこで参照先の値である u64 の型を関数に渡している
    let mut d = numbers[0];
    for m in &numbers[1..] {
        d = gcd(d, *m);
    }

    println!("The greatest common divisor of {:?} is {}", numbers, d);

    // main関数の最後でnumbersがスコープから外れると、ベクタは自動的に解放される
}

/**
 * ユークリッドの互助法
 *
 * 符号なしの64ビット整数の引数に受け取り、同じ型の値を返す。
 */
fn gcd(mut n: u64, mut m: u64) -> u64 {
    // 引数で0を受け取ると、パニックで終了する
    assert!(n != 0 && m != 0);
    while m != 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    // セミコロンなしの式の場合は、この式が関数の返り値となる
    // Rustでは return は早期リターンの時には使わない
    n
}

// テスト関数であることを示す
// 通常のコンパイル時にはスキップされるが、 cargo test で自動的にコンパイルされ実行される
#[test]
fn test_gcd() {
    assert_eq!(gcd(14, 15), 1);

    assert_eq!(gcd(2 * 3 * 5 * 11 * 17, 3 * 7 * 11 * 13 * 19), 3 * 11)
}
